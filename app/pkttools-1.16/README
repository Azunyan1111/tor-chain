pkttools
製作：坂井弘亮 (KOZOSプロジェクト)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ 概要

パケットキャプチャ＆送信などを行うテキストベースの簡易ツール群です．
各ツールはパイプで繋げて連携させることができます．
テキストベースなので，パケットをパッと見てみたりちょっと修正して再送信
したり，各種スクリプトを組み合わせて利用したりということが簡便にできます．

(重要！)
本ツールはネットワークの勉強・検証を目的として作成・配布するものです．
不用意な利用はネットワークに様々な影響を与えたり，様々な問題を引き起こす
可能性があるため，ツールの動作を理解した上で，ローカル環境で利用するか
ネットワーク管理者の許可を得た上で利用するようにしてください．勉強や検証を
目的として，正しいモラルのもとで利用してください． 

以下のツールがあります．

・簡易パケットキャプチャ
・簡易パケット送信
・pcap/pcapngフォーマットとの変換 (Wiresharkと連携できます)
・バイナリデータとの変換 (バイナリエディタと連携できます)
・フラグメント・パケットの分割／再構築
・簡易パケットアナライザ
・チェックサム再計算
・パケットの簡易チェック
・パケットフィルタ
・パケット変換
・ping応答ツール

FreeBSD/Linux両用です．
FreeBSD-8.4/CentOS6.5の環境でコンパイルと動作確認しています．

フリーソフトウェアです．ご自由にお使いください．
ただし無保証です．本ツールを利用することで発生した不具合や問題などについて，
作者は一切の責任を負いません．各自の責任の下で利用してください． 
ライセンスは KL-01 と LICENSE を参照してください．

作者の連絡先は以下です．バグ報告など歓迎します．
(ただし，必ず返信するとは限りません)
kozos[アットマーク]kozos.jp

■ ツール一覧

pkt-recv       ... パケットキャプチャして，受信データをテキスト出力
pkt-send       ... テキスト入力されたパケットを送信
pkt-txt2txt    ... テキスト入力されたパケットをテキストで再出力(テキストの整形)
pkt-txt2pcap   ... テキスト入力されたパケットをpcapフォーマットに変換
pkt-pcap2txt   ... pcapフォーマットを解読してテキスト出力する
pkt-txt2pcapng ... テキスト入力されたパケットをPcapNgフォーマットに変換
pkt-pcapng2txt ... PcapNgフォーマットを解読してテキスト出力する
pkt-txt2bin    ... テキスト入力されたパケットをバイナリデータに変換
pkt-bin2txt    ... バイナリデータを変換してテキスト出力する
pkt-fragment   ... IPv4/IPv6パケットをフラグメント分割する
pkt-defragment ... フラグメント分割されたIPv4/IPv6パケットを再構築する
pkt-analyze    ... テキスト入力されたパケットを解析
pkt-correct    ... テキスト入力されたパケットのチェックサムを再計算して再出力
pkt-check      ... テキスト入力されたパケットの簡易チェックをして再出力
pkt-filter     ... テキスト入力されたパケットをフィルタして再出力(※１)
pkt-change     ... テキスト入力されたパケットを変換して再出力(※１)
pkt-pingrep    ... テキスト入力されたパケットからpingの応答パケットを出力する

※１ ルールをソースコードに直接記述してコンパイルしなおして利用する

■ パケットの出力の例

パケットを出力するツール(pkt-recvなど)は，以下のようなテキストフォーマットで
出力します．
パケットを入力するツール(pkt-sendなど)は，以下のようなテキストフォーマットの
入力を受け付けます．
(つまり，それらはパイプで連結して使えます)

user@letsnote:~/pkttools>% pkt-recv -i em0
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 1400167480.561500 Fri May 16 00:24:40 2014
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==
-- 2 --
TIME: 1400167480.561510 Fri May 16 00:24:40 2014
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==

「--」〜「==」でくくられている部分が，１個のパケットになります．
(上の例では２個のパケットが出力されています)
テキスト出力をいったん保存し，テキストエディタで特定のパケットのみ切り出したり
パケットを部分的に書き換えて，他のツールに印加することができます．

例えばpkt-recvで受信したデータをいったんテキストファイルとして保存し，
テキストエディタで特定のパケットのみ切り出して再度保存，pkt-sendで送信する
ことで，特定のパケットのみ繰り返し送信したりすることができます．
以下のような流れです．

% pkt-recv -i eth0 > capture.txt
^C  (適当な時間経過後に，Ctrl-Cで強制終了)
% vi capture.txt  (編集)
% cat capture.txt | pkt-send -i eth0  (送信)

pcapフォーマットと連携できます．例えばWiresharkでキャプチャしたパケットをpcap
で一旦保存，pkt-pcap2txt で上記テキストフォーマットに変換，変換したテキスト
ファイルをテキストエディタで修正，pkt-txt2pcap でpcapフォーマットに戻す，と
いったことができます．

% cat capture.pcap | pkt-pcap2txt > capture.txt
% vi capture.txt  (編集)
% cat capture.txt | pkt-txt2pcap > capture.pcap
% wireshark capture.pcap  (Wiresharkで参照)

PcapNgフォーマット用には pkt-pcapng2txt / pkt-txt2pcapng が利用できます．

他にもWiresharkのキャプチャ結果(capture.pcap)からUDPパケットのみ
取り出したい場合には，以下のようにできます．

% cat capture.pcap | pkt-pcap2txt IP.PROTOCOL==17 | pkt-txt2pcap > cap2.pcap
% wireshark cap2.pcap  (Wiresharkで参照)

このようにテキストエディタで扱ったり，パイプによるスクリプト処理がしやすい
ような作りになっています．

■ パケットのサンプル

各種のパケットのサンプルデータが，samplesというディレクトリに置かれています．

パケット自作などのサンプルに使えるかと思います．

■ ソケット利用の簡易ツール

ソケットをオープンしてデータを送受信する簡易ツールを tools というディレクトリ
に置いてあります．ソケット利用のサンプルコードとしても利用できるかと思います．
またこのような用途にはnetcatが便利ですが，netcatが無い場合に便利かと思います．

IPv4/IPv6, TCP/UDP, 送信/受信の組合せで，以下の合計16通りのツールがあります．

tcp-send    / tcp6-send    / udp-send    / udp6-send
tcp-recv    / tcp6-recv    / udp-recv    / udp6-recv
tcp-request / tcp6-request / udp-request / udp6-request
tcp-reply   / tcp6-reply   / udp-reply   / udp6-reply

*-send はデータの送信，*-recv はデータの受信です．
*-request はデータを送信後，応答を待ちます．*-reply はデータを受信後，
応答として受信したデータをそのまま返します．

以下のようにして利用します．

(データの送受信)

・受信側

  % tcp-recv 10000

・送信側

  % cat sample.txt | tcp-send 192.168.1.1 10000

(サーバの応答確認)

・サーバ側

  % udp-reply 10000

・クライアント側

  % echo "test" | udp-request 192.168.1.1 10000

(HTMLの取得)

  % printf "GET /index.html HTTP/1.0\n\n" | tcp-request server.mydomain.net 80

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ 使いかた

■ コンパイル方法

解凍して make するだけです．(./configureは不要です)
FreeBSD/Linuxの両環境でコンパイル確認してあります．

ソケット利用の簡易ツールも使いたい場合には，toolsディレクトリで別途makeして
ください．

■ 使うときの注意点(FreeBSD/Linuxの場合)

・FreeBSDの場合
  まず準備としてFreeBSDの場合は，スーパーユーザで以下をやっておきます．
  # chmod 666 /dev/bpf*

・Linuxの場合
  とくに準備はありませんが，pkt-recv / pkt-send はスーパーユーザで
  実行する必要があります．(RAWソケットを利用するため)

まず ifconfig コマンドにより，使用できるインターフェース一覧を参照します．
FreeBSDだと fxp0 とか em0 とか rl0 のようなのが使えます．
Linuxだと eth0, eth1, ... のようなのが使えます．

必要に応じて，インターフェースを有効化します．
(inconfigでインターフェースにUPフラグが立っていない場合には必要です)

# ifconfig em0 up

■ 使うときの注意点(Windowsの場合)

pkt-recv/pkt-sendをインターフェース未指定で実行することで，
インターフェースの一覧が出力されます．

C:\> pkt-recv
        0       ...
        1       ...
        2       ...

左側の番号がインターフェース番号になります．一覧からインターフェースを選択
して，以下のようにインターフェースを番号で指定してください．

C:\> pkt-recv -i 1

■ 使いかたの例

以下は Linux で eth0 を使う場合の例です．

・パケットの受信

  % pkt-recv -i eth0

・パケットをキャプチャして解析して表示

  % pkt-recv -i eth0 | pkt-analyze

・パケットをキャプチャして各フィールド値を表示

  % pkt-recv -i eth0 -a

・eth0 → eth1 にパケットをブリッジする

  % pkt-recv -i eth0 | pkt-send -i eth1

・IPパケットのみブリッジ

  % pkt-recv -i eth0 ETHERNET.TYPE==0x0800 | pkt-send -i eth1

・宛先が192.168.1.Xのパケットのみブリッジ

  % pkt-recv -i eth0 "IP.DST_ADDR>=192.168.1.0" \
            | pkt-txt2txt "IP.DST_ADDR<=192.168.1.255" | pkt-send -i eth1

・TTL値を書き換えてチェックサム再計算してブリッジ

  % pkt-recv -i eth0 IP.TTL=0xFF | pkt-correct | pkt-send -i eth1

・eth0 ←→ eth1 の間を双方向にブリッジする (簡易ブリッジ)

  % (pkt-recv -i eth0 -ro | pkt-send -i eth1) &
  % (pkt-recv -i eth1 -ro | pkt-send -i eth0) &

・パケットを一旦保存し解析．さらに別インターフェースに強制送信

  % pkt-recv -i eth0 > capture.txt
  % cat capture.txt | pkt-analyze
  % cat capture.txt | pkt-send -i eth1

・パケットをpcapフォーマットで保存し，あとで Wireshark で開く

  % pkt-recv -i eth0 | pkt-txt2pcap > capture.pcap
  % wireshark capture.pcap

・Wiresharkでキャプチャし保存したパケット(capture.pcap)をeth0に強制送信

  % cat capture.pcap | pkt-pcap2txt | pkt-send -i eth0

・pcapngからpcapフォーマットへの変換

  % cat capture.pcapng | pkt-pcapng2txt | pkt-txt2pcap > capture.pcap

・１個のパケットをバイナリデータとして保存しバイナリエディタで開く

  % pkt-recv -i eth0 -l 1 | pkt-txt2bin > capture.bin
  % hexedit capture.bin

・バイナリエディタで作成・編集したパケットを送信

  % hexedit capture.bin
  % cat capture.bin | pkt-bin2txt | pkt-send -i eth0

・チェックサムがエラーのパケットを出力する

  % pkt-recv -i eth0 | pkt-check | pkt-check -cs -rc

・キャプチャしたパケットを改造してチェックサムを再計算し再送信

  % pkt-recv -i eth0 > capture.txt
  % vi capture.txt
  % cat capture.txt | pkt-correct | pkt-send -i eth0

・受信したARPとICMP Echoにすべて応答する(あらゆるpingに応答します)

  % pkt-recv -i eth0 -ro | pkt-pingrep | pkt-send -i eth0

・Ｌ３〜Ｌ４層を解析し，簡易的な情報のみ出力する

  % pkt-recv -i eth0 | pkt-analyze -ll 3 -lh 4 -lv 2

・Ｌ４層のみ解析し，ペイロードのダンプも出力する

  % pkt-recv -i eth0 | pkt-analyze -ll 4 -lh 4 -lv 5

・フラグメント分割されたパケットを再構築し，チェックサム再計算して再度分割

  % cat capture.txt | pkt-defragment | pkt-correct | pkt-fragment

・MTU=1200でフラグメントし，さらにMTU=1000でフラグメントする

  % cat capture.txt | pkt-fragment -fm 1200 | pkt-fragment -fm 1000

■ 各種オプション

共通

  -h		ヘルプを出力
  -k		簡易フィルタ等のフィールド指定のキーワード一覧を出力
  -b <size>	バッファサイズを指定
		(標準では80KB．pkt-recvではゼロを指定すると自動設定)
  -s <count>	指定した数のパケットをスキップしてから処理する
  -l <count>	指定した数のパケットを処理したら終了する
  -r		フィルタ判定を反転する
		(マッチしたもののみ通過 → マッチしたもののみ遮断)
  -n <count>	テキスト出力時の桁数
  -a		各フィールドの値を出力
  -nb		ブロードキャストパケットを無視する
  -nm		マルチキャストパケットを無視する
  -do		データのみ出力する
  -lt <type>	データリンク層のタイプを指定する(Ethernetは１)

pkt-recv

  -i <ifname>	受信インターフェースを指定する
  -np		プロミスキャスモードにしない (標準ではプロミスキャスモード)
  -ro		自分が送信したパケットは受信しない (標準では双方向受信)
  -so		自分が受信したパケットは受信しない (標準では双方向受信)

pkt-send

  -i <ifname>	送信インターフェースを指定する
  -w <microsec>	送信時にウェイトを入れる (-fでの送信が速すぎる際に利用できる)
  -c		送信元MACアドレスを，自身のMACアドレスで自動補完して送信する
		(ただしlibpcapでビルドした場合(Windows版など)は利用不可)
  -f		パケットの時刻を見ずに連続で送信する
		(標準では受信時刻の差分を見て，受信時と同じ間隔で送信する)
  -j		パケット送信時の時刻を，直前のパケットに対して計算する
		(標準では最初のパケット送信の時刻に対して計算する)
		(このオプションを利用すると，誤差が積み重なっていく可能性あり)

pkt-fragment

  -fm <layer>	フラグメントのMTU(Maximum transmission unit)
  -fc		Don't fragment フラグを無視する(強制的にフラグメントする)

pkt-analyze

  -ll <layer>	解析するネットワーク階層の下限(ゼロで下限無し．標準ではゼロ)
  -lh <layer>	解析するネットワーク階層の上限(ゼロで上限無し．標準ではゼロ)
  -lv <level>	出力のレベル(標準では３)
		0 ... すべての解析結果を出力
		1 ... プロトコル情報のみ出力
		2 ... 各ヘッダの重要な情報のみ１行／１ヘッダで出力
		3 ... ヘッダ情報を出力
		4 ... ペイロードがある場合はペイロードの先頭部分のみ出力
		5 ... ペイロードの全体を出力

pkt-check

  -cs		チェックサムが正しいかどうかをチェックする
  -rc		チェック結果の動作を逆転する
		(デフォルトではチェックＯＫで出力，ＮＧで出力しない)

pkt-txt2pcap / pkt-txt2pcapng

  -ne		ネイティブのエンディアンで出力する(デフォルト)
  -le		リトルエンディアンで出力する
  -be		ビッグエンディアンで出力する

■ バイナリデータの扱い

以下のようにして受信したパケットをバイナリファイルとして保存することができ
ます．(pcapフォーマットではなく，生のバイナリデータになります)

% pkt-recv -i eth0 | pkt-txt2bin -l 1 > capture.bin

上の例では後述のパケット連結の問題があるため，-l 1 を指定して１パケットのみ
を保存しています．

また，バイナリデータは以下のようにして送信できます．

% cat capture.bin | pkt-bin2txt | pkt-send -i eth0

ただしバイナリデータにした場合，以下の注意が必要です．

・連続した複数のパケットを区別する手段が無いため，バイナリデータ上ではパケット
  が連結してしまいます．(ひとつの巨大なパケットみたいな感じになります)

・受信時刻などの付加情報は失われます．

つまり以下のようなことをしても，期待通りに動作しません．

% pkt-recv -i eth0 | pkt-txt2bin > capture.bin
^C  (適当な時間経過後に，Ctrl-Cで強制終了)
% cat capture.bin | pkt-bin2txt | pkt-send -i eth0
(複数のパケットが連結してひとつの巨大なパケットとして送信されてしまう)

このためバイナリデータにしたい場合には，-l 1 を指定して１パケット単位で扱う
ことを推奨します．(もともとこの機能は，バイナリエディタと連携して単一の
パケットを扱うようなことを想定しています)

例えばパケットをバイナリエディタで直に編集して Wireshark で解析したいような
場合には，以下のようなこともできます．

% cat capture.pcap | pkt-pcap2txt -l 1 | pkt-txt2bin > capture.bin
% hexedit capture.bin  (バイナリエディタで編集)
% cat capture.bin | pkt-bin2txt | pkt-txt2pcap > capture.pcap
% wireshark capture.pcap  (Wiresharkで参照)

ただし上述したようにバイナリデータにした時点で受信時刻の情報は失われ，
上の例だと capture.pcap の受信時刻は pkt-bin2txt が実行されたときの時刻が
設定されます．

■ チェックサムの再計算

pkt-correct はチェックサムの再計算を行いますが，フラグメント分割された
パケットの場合，チェックサムを計算できません．
(計算できない部分は処理せずに，そのまま出力します)

これはUDPなどのパケットがフラグメント分割された場合に，複数のパケットに渡って
チェックサム計算を行う必要があるためです．

以下のように pkt-defragment / pkt-fragment を通すことで，フラグメント・パケット
をいったん再構築し，全体を通してチェックサム計算した後に，再度フラグメント分割
することができます．

% cat udp.txt | pkt-defragment | pkt-correct | pkt-fragment > udp2.txt

■ パケットのチェック

pkt-check はパケットの簡単なチェックし，ＯＫのもののみ出力します．
(サイズなどをチェックし，チェックサム計算が行える正当なパケットかどうかを
チェックする)

% pkt-recv -i eth0 | pkt-check

-rcオプションを付けると，結果の動作を逆転します．
デフォルトではチェックＯＫで出力，ＮＧは出力しない
-rcオプション付加ではチェックＮＧで出力，ＯＫは出力しない

% pkt-recv -i eth0 | pkt-check | pkt-check -rc

-csオプションを付けると，さらにチェックサムの正当性をチェックします．

以下は，チェックサムエラーのパケットを出力します．

% pkt-recv -i eth0 | pkt-check -cs -rc

ただしこれだと，単なるエラーパケットも出力されてしまいます．
チェックサムエラーのパケットを出力させたいが，そもそものエラーパケットは
出力させたくない，という場合は，以下のようにして pkt-check を事前に挟んで
エラーパケットをフィルタしてください．

% pkt-recv -i eth0 | pkt-check | pkt-check -cs -rc

■ IPv4/IPv6フラグメント処理

pkt-fragment / pkt-defragment でIPv4/IPv6パケットのフラグメントと，
フラグメントされたパケットの再構築ができます．

既にフラグメントされているパケットをさらにフラグメントすることもできます．

パケットの順番が入れ替わっていても，問題なく再構築してくれます．
ただしパケットの抜け(再構築した際のデータの抜け)があると再構築されません．

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ テキストデータの書式について

■ パケットデータはテキストで扱われます

パケットデータは以下のようなテキスト形式で扱われます．
以下は pkt-recv で受信したパケットを，pkt-send で別のインターフェースに
送信してみる例です．

user@letsnote:~/pkttools>% pkt-recv -i rl0 -l 1 > capture.txt (rl0で受信)
user@letsnote:~/pkttools>% cat capture.txt
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 1400296569.633895 Sat May 17 12:16:09 2014
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : ..gQ.... ......E.
000010: 00 54 59 86  00 00 40 01  9D C4 C0 A8  01 0D C0 A8 : .TY...@. ........
000020: 01 01 08 00  D2 DA 66 11  00 00 53 76  D4 79 00 09 : ......f. ..Sv.y..
000030: AC 17 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==
user@letsnote:~/pkttools>% cat capture | pkt-send -i rl1  (rl1に送信)

capture.txtをテキストエディタで適当にデータを書き換えて送信することができます．
つまり，パケットの内容を適当に書き換えて送信することができます．
(データを書き換えることでIPやUDPのチェックサムが変わってしまう場合は，
pkt-correct を通すことでチェックサムが再計算され再設定されます)

■ テキストデータのフォーマット

まずテキストデータ中では，「--」と「==」で囲まれている部分を１つのパケット
データとして扱います．

上記の例では出力時に「-- 1 --」のようにパケットの番号が付加されていますが，
番号は無視されるので適当で構いませんし，「--」のように省略しても構いません．

「--」と「==」の外では「LINKTYPE:」によりデータリンクのタイプが指定されます．
(pkttools-1.13より追加されました)
ただし省略も可能です．(省略された場合には Ethernet とみなされます)

テキストデータの右側にはASCII文字がありますが，データを書き換える場合，
ASCII文字部分はデータに合わせて書き換える必要はありません．
(ASCII文字部分は無視されますので，そもそも削ってしまっても構いません)

また「TIME:」や「SIZE:」の表記は省略できます．
さらにデータは１行に16個でなくても構いません．

例えば，以下のようなテキストデータを pkt-send に与えても問題なく解釈されて
出力されます．
(上のcapture.txtと等価になります．なお先頭の「--」と終端の「==」は必要です)

--
00 11 22 33 44 55 00 AA BB CC DD EE 08 00 45 00  00 54 59 86 00 00 40 01 9D C4 C0 A8 01 0D C0 A8
01 01 08 00 D2 DA 66 11 00 00 53 76 D4 79 00 09  AC 17 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15
16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25  26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35  36 37
==

もちろん上記データは，pkt-send 以外の pkt-analyze や pkt-txt2pcap に与えても
問題なく解釈されます．(テキストデータの入出力には，同じ処理を利用しています)

■ テキストデータの整形

テキストデータは pkt-txt2txt を通すことで整形されます．
実際にどのようなデータが出力されるのかを確認したい場合には
pkt-txt2txtを通してみるといいでしょう．

user@letsnote:~/pkttools>% cat capture2.txt
--
00 11 22 33 44 55 00 AA BB CC DD EE 08 00 45 00  00 54 59 86 00 00 40 01 9D C4 C0 A8 01 0D C0 A8
01 01 08 00 D2 DA 66 11 00 00 53 76 D4 79 00 09  AC 17 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15
16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25  26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35  36 37
==
user@letsnote:~/pkttools>% cat capture2.txt | pkt-txt2txt
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.0 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 59 86  00 00 40 01  9D C4 C0 A8  01 0D C0 A8 : .TY...@. ........
000020: 01 01 08 00  D2 DA 66 11  00 00 53 76  D4 79 00 09 : ......f. ..Sv.y..
000030: AC 17 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67               
==
user@letsnote:~/pkttools>% 

■ 桁数の調整

-n オプションで，出力するテキストデータの桁数を指定することができます．

% cat capture2.txt | pkt-txt2txt -n 10
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC : .."3DU.. ..
00000A: DD EE 08 00  45 00 00 54  59 86 : ....E..T Y.
000014: 00 00 40 01  9D C4 C0 A8  01 0D : ..@..... ..
00001E: C0 A8 01 01  08 00 D2 DA  66 11 : ........ f.
000028: 00 00 53 76  D4 79 00 09  AC 17 : ..Sv.y.. ..
000032: 08 09 0A 0B  0C 0D 0E 0F  10 11 : ........ ..
00003C: 12 13 14 15  16 17 18 19  1A 1B : ........ ..
000046: 1C 1D 1E 1F  20 21 22 23  24 25 : .... !"# $%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F : &'()*+,- ./
00005A: 30 31 32 33  34 35 36 37        : 01234567
==

■ 文字表示の削除

文字表示部分を削除するオプションはありませんが，Perlと組み合わせて削ることが
できます．

% cat capture2.txt | pkt-txt2txt | perl -pe 's/ : .*//'
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00
000010: 00 54 59 86  00 00 40 01  9D C4 C0 A8  01 0D C0 A8
000020: 01 01 08 00  D2 DA 66 11  00 00 53 76  D4 79 00 09
000030: AC 17 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35
000060: 36 37
==

他にも，テキスト整形したい場合にはPerlなどと組み合わせてください．
簡素なツールであるためオプションを過剰に追加することは避けたいので，
スクリプトを介すことでできることはツール側ではやらない，という考えです．

以下は空白を詰める例です．

% cat capture2.txt | pkt-txt2txt | perl -pe 's/ : .*//' | perl -pe 's/  / /g'
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.000000 Thu Jan 1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33 44 55 00 AA BB CC DD EE 08 00 45 00
000010: 00 54 59 86 00 00 40 01 9D C4 C0 A8 01 0D C0 A8
000020: 01 01 08 00 D2 DA 66 11 00 00 53 76 D4 79 00 09
000030: AC 17 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15
000040: 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25
000050: 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35
000060: 36 37
==

以下は TIME: と SIZE: の表示を削除する例です．

% cat capture2.txt | pkt-txt2txt | grep -v ^L | grep -v ^T | grep -v ^S
-- 1 --
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 59 86  00 00 40 01  9D C4 C0 A8  01 0D C0 A8 : .TY...@. ........
000020: 01 01 08 00  D2 DA 66 11  00 00 53 76  D4 79 00 09 : ......f. ..Sv.y..
000030: AC 17 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==

■ テキストデータの表記の詳細

以下，データの表記方法の詳細です．

・LINKTYPE: の指定について (pkttools-1.13より追加)

  ＊省略できます．省略すると１(Ethernet)を指定したことになります．
  ＊指定は数値で行います．数値に後続する「(Ethernet)」等の表記は無視されます．
  ＊-ltオプションで強制的に設定することもできます．
  ＊pkt-analyzeは指定されたタイプに応じてパケットの解析を行います．
    またタイプ値は pkt-txt2pcap / pkt-txt2pcapng による出力に埋め込まれます．

・TIME: の指定について

  ＊省略できます．省略すると現在時刻を指定したことになります．
  ＊「Sat May 17 12:16:09 2014」のような日付表示は省略できます．(無視されます)
  ＊書式は「TIME: <秒>.<マイクロ秒>」です．
    「100」や「100.」は「100.0」と同義です．「.100」は「0.100」と同義です．
  ＊pkt-sendによる送信時には，TIME: で指定された時刻に送信間隔を合わせて
    送信されます．0.0 の場合には即時送信します．

・SIZE: の指定について

  ＊省略できます．省略するとデータ数から自動計算されます．
  ＊書式は「SIZE: <キャプチャ量>/<オリジナルのデータ量>」です．
    「100」は「100/100」と同義，「100/」は「100/0」と同義になります．
  ＊SIZE:によるサイズ指定とデータ数が異なる場合はSIZE:によるサイズ指定が
    優先され，以下のようになります．
    「サイズ指定＜データ数」の場合 ... サイズを超えたデータは無視されます．
    「サイズ指定＞データ数」の場合 ... 足りないデータはゼロで埋められます．

・データの表記について

  ＊「000000: 00 11 22 33」のような表記は，先頭の「000000:」(オフセット表記)
    は無視され，その後の「00 11...」をデータとして扱います．
  ＊「00 11 22 33」のような表記は，そのままデータとして扱います．
  ＊オフセット表記がある場合，オフセットのとおりにデータを読むのではなく，
    オフセット表記は無視されます．
  ＊例えば以下のようにオフセット表記が逆転している場合にも，
    読まれるデータは「00 11 22 33 44 55 66 77」のような順番
    (データの表記順)になります．

    000004: 00 11 22 33
    000000: 44 55 66 77

  ＊データ表記は「ab」のように小文字でも「AB」のように大文字でも構いません．
  ＊データ表記は２桁が基本ですが，１桁で書くこともできます．
    例えば「A」は「0A」と等価です．
  ＊データを２桁以上で書いた場合，下２桁が読み込まれます．
    つまり「ABCD」と書いた場合には，実際のデータは「CD」になります．
  ＊右端のASCII文字は無視されます．(「:」以降はコメントとして無視されます)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ パケットフィルタとパケット変換 (簡易版)

簡易フィルタ・簡易パケット変換の機能があります．
全てのツールで共通で利用できます．

■ 簡易フィルタの方法

オプションで以下のようにフィルタ条件を指定することで，簡易フィルタを
かけられます．(複雑な条件は指定できません．複雑なフィルタをかけたい場合は
pkt-filter を利用してください)

全てのツールで利用できます．(pkt-analyze, pkt-send などでも利用可能)

pkt-recv -i eth0 ETHERNET.TYPE==0x0806 ... ARPのみ通過
pkt-recv -i eth0 ETHERNET.TYPE==0x0800 ... IPのみ通過
pkt-recv -i eth0 ETHERNET.TYPE==0x86DD ... IPv6のみ通過

pkt-recv -i eth0 IP.PROTOCOL==1  ... ICMPのみ通過
pkt-recv -i eth0 IP.PROTOCOL==6  ... TCPのみ通過
pkt-recv -i eth0 IP.PROTOCOL==17 ... UDPのみ通過

指定できる条件は以下です．
('<'や'>'が入る場合，リダイレクションと間違えないように""でくくります)

pkt-recv -i eth0 UDP.DST_PORT==80   ... UDPで80番ポートのみ通過
pkt-recv -i eth0 UDP.DST_PORT!=80   ... UDPで80番ポート以外を通過
pkt-recv -i eth0 "UDP.DST_PORT<80"  ... UDPで80番ポート未満を通過
pkt-recv -i eth0 "UDP.DST_PORT>80"  ... UDPで80番ポートより上を通過
pkt-recv -i eth0 "UDP.DST_PORT<=80" ... UDPで80番ポート以下を通過
pkt-recv -i eth0 "UDP.DST_PORT>=80" ... UDPで80番ポート以上を通過

各フィールド指定のキーワード(上記の「UDP.DST_PORT」とか)はツールを -k で
実行することで一覧を出力させられます．

MACアドレス，IPアドレス，IPv6アドレス，文字列も同様の演算子で比較できます．

pkt-recv -i eth0 IP.SRC_ADDR==192.168.1.1 ... IPアドレスが192.168.1.1を通過

pkt-recv -i eth0 "IP.DST_ADDR>=192.168.1.0" \
        | pkt-txt2txt "IP.DST_ADDR<=192.168.1.255"
 ... IPアドレスが192.168.1.Xの場合に通過

フィルタ条件を複数記述した場合には，OR論理になります．

pkt-recv -i eth0 UDP.SRC_PORT==80 UDP.DST_PORT==80
  ... 送信元と宛先のいずれかが80番ポートの場合に通過

AND論理でフィルタをかけたい場合には，以下のようにツールを２重に通過させて
ください．

pkt-recv -i eth0 UDP.SRC_PORT==80 | pkt-txt2txt IP.SRC_ADDR==192.168.1.1

デフォルトではフィルタ条件を記述すると，マッチしたもののみ通過になります．
-r を付加すると判断が逆転します．

pkt-recv -i eth0 -r UDP.DST_PORT==80 ... UDPの80番ポートを遮断

以下のようになります．

pkt-recv -i eth0 UDP.DST_PORT==80    ... UDP80番ポートを通過，UDP以外は遮断
pkt-recv -i eth0 UDP.DST_PORT!=80    ... UDP80番ポート以外を通過，UDP以外は遮断
pkt-recv -i eth0 -r UDP.DST_PORT==80 ... UDP80番ポートを遮断，UDP以外は通過
pkt-recv -i eth0 -r UDP.DST_PORT!=80 ... UDP80番ポート以外を遮断，UDP以外は通過

■ 簡易パケット変換の方法

以下のようにオプション指定することで，フィールド値の書き換えを行うことが
できます．(複雑な書き換えはできません．複雑な書き換えをしたい場合は
pkt-change を利用してください)

全てのツールで利用できます．(pkt-analyze, pkt-send などでも利用可能)

pkt-recv -i eth0 UDP.DST_PORT=80 ... UDPの宛先ポート番号を80に変換して出力

数値は10進でも16進でも指定可能です．16進の場合は0xを付加してください．

MACアドレス，IPアドレス，IPv6アドレス，文字列も指定できます．

パケットの内容が変換された際，チェックサムの再計算が必要になる場合があります．
必要ならば pkt-correct を通すことで再計算・再設定してくれます．

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ パケット変換 (スクリプトにより，フィールド値を指定して書き換え)

■ フィールド値を指定して変換する

テキスト出力の中でフィールド値の書き換えを指定することができます．
例えば以下のような出力があるとします．

-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==

ここで出力されたテキストに対して，テキストエディタやスクリプトなどで以下の
ようにIP.TTLの値の指定を追加するとします．

-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
IP.TTL: 0xFF    (TTLの指定を末尾に追加した)
==

上記 IP.TTL を追加したテキストをツールに流し込むと，TTL値を0xFFに変換した上で
処理を行います．(全ツール共通です)
ちょっとしたデータ変換を行ったり，スクリプトで処理したりするときに便利です．
(必要ならば pkt-correct を通すことでチェックサムを再設定できます)

■ フィールド値を出力させる

各ツールは -a オプションを付加して実行すると，バイトデータに続いて各フィールド
の値を出力します．以下のような感じです．

% cat packet.txt
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==
% cat packet.txt | pkt-txt2txt -a
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 00 00  00 00 40 01  F7 55 C0 A8  01 01 C0 A8 : .T....@. .U......
000020: 01 02 08 00  4A 2F 03 0F  00 00 53 8A  C4 11 00 07 : ....J/.. ..S.....
000030: A8 1B 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
ETHERNET.DST_ADDR:      00:11:22:33:44:55
ETHERNET.SRC_ADDR:      00:aa:bb:cc:dd:ee
ETHERNET.TYPE:          0x800
IP.VERSION:             0x4
IP.HEADER_SIZE:         0x14
IP.TOS:                 0x0
IP.TOTAL_SIZE:          0x54
IP.ID:                  0x0
IP.FRAGMENT:            0x0
IP.TTL:                 0x40
IP.PROTOCOL:            0x1
IP.CHECKSUM:            0xf755
IP.SRC_ADDR:            192.168.1.1
IP.DST_ADDR:            192.168.1.2
ICMP.TYPE:              0x8
ICMP.CODE:              0x0
ICMP.CHECKSUM:          0x4a2f
==

「IP.ID」や「IP.TTL」のようにして，プロトコルの各フィールドの値が出力されて
います．

■ スクリプトと組み合わせてフィールド値を書き換える

ここで例えばIP.TTLを以下のように書き換えて他のツールに入力すると，当該の
フィールドの値を書き換えてデータを扱います．
(すべてのフィールドを記述する必要はありません．記述があるフィールドのみ
パケット上の値の上書きが行われます)

IP.TTL:                 0x40
↓
IP.TTL:                 0xFF

これはスクリプトでの処理に向いています．例えば以下のようにPerlと組み合わせる
ことで，TTLを0xFFに変換して転送することができます．
(チェックサム再計算の必要があるため，変換後に pkt-correct を通しています)

pkt-recv -i eth0 -a | perl -pe 's/IP\.TTL:.*/IP\.TTL: 0xFF/' \
        | pkt-correct | pkt-send -i eth1

＃ もちろんこれは，以下のようにして簡易パケット変換でも実現可能です．
＃ pkt-recv -i eth0 IP.TTL=0xFF | pkt-correct | pkt-send -i eth1
＃ が，スクリプトで細かい変換制御など行いたい場合は，上のようにPerlなどと
＃ 組み合わせられると強力でしょう．(例えばアドレスを１ずつ変化させたいなど)

フィールド値が複数指定されている場合には，後のほうの指定が有効になります．
このため「==」の直前にフィールド値指定の行を追加することで，フィールド値を
上書きできます．これもスクリプトでの処理がやりやすいと思います．

■ 簡易フィルタ・簡易パケット変換・フィールド値指定などの動作について

簡易フィルタと簡易パケット変換の処理の順番は，以下のようになっています．
以下の動作はpkttoolsのすべてのツールに共通です．

１．入力を行う．テキスト入力の場合，まずバイトデータを読み込み，さらに
    フィールド値の指定がある場合にはその値に変換する．フィールド値の指定が
    無い場合はそのまま．

２．実行時オプションで簡易フィルタが指定されている場合には，適用する．

３．行うべき処理がある場合には，当該の処理を行う．
    (たとえば pkt-correct ではチェックサム計算など)

４．実行時オプションで簡易パケット変換が指定されている場合には，変換を行う．

５．出力を行う．テキスト出力の場合，-a オプションが付加されているならば
    各フィールドの値も出力する．

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ パケット変換 (スクリプトにより，特定のオフセット位置を書き換え)

■ -n 1 による出力

特定のバイト位置を書き換えたい場合ですが，以下のようにするのが簡単です．

まず -n 1 を指定して，出力桁数を１にします．

% cat packet.txt | pkt-txt2txt
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 54 59 86  00 00 40 01  9D C4 C0 A8  01 0D C0 A8 : .TY...@. ........
000020: 01 01 08 00  D2 DA 66 11  00 00 53 76  D4 79 00 09 : ......f. ..Sv.y..
000030: AC 17 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==
% cat packet.txt | pkt-txt2txt -n 1
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 : .
000001: 11 : .
000002: 22 : "
000003: 33 : 3
000004: 44 : D
000005: 55 : U
...

これで行ごとに１バイト単位で編集できるので，以下のようにスクリプトを通して
特定位置を変更することができます．以下は６バイト目(宛先MACアドレスの下１桁)を
「FF」に書き換えた例です．

% cat packet.txt | pkt-txt2txt -n 1 | perl -pe 's/^000005:.*/000005: FF/' \
        | pkt-txt2txt
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  44 FF 00 AA  BB CC DD EE  08 00 45 00 : .."3D... ......E.
000010: 00 54 59 86  00 00 40 01  9D C4 C0 A8  01 0D C0 A8 : .TY...@. ........
000020: 01 01 08 00  D2 DA 66 11  00 00 53 76  D4 79 00 09 : ......f. ..Sv.y..
000030: AC 17 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==

もちろん -n 2 のようにして，２バイト単位で書き換えることもできます．

% cat packet.txt | pkt-txt2txt -n 2 | perl -pe 's/^000004:.*/000004: EE FF/' \
        | pkt-txt2txt
LINKTYPE: 1 (Ethernet)
-- 1 --
TIME: 0.000000 Thu Jan  1 09:00:00 1970
SIZE: 98/98
000000: 00 11 22 33  EE FF 00 AA  BB CC DD EE  08 00 45 00 : .."3.... ......E.
000010: 00 54 59 86  00 00 40 01  9D C4 C0 A8  01 0D C0 A8 : .TY...@. ........
000020: 01 01 08 00  D2 DA 66 11  00 00 53 76  D4 79 00 09 : ......f. ..Sv.y..
000030: AC 17 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &'()*+,- ./012345
000060: 36 37                                              : 67
==

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ パケットフィルタとパケット変換 (複雑なものを行いたい場合)

■ pkt-filter/pkt-change によるパケットフィルタ／パケット変換

前述の簡易フィルタ／簡易パケット変換で実現できないような複雑なフィルタや
パケット変換を行うためのテンプレートとして，pkt-filter/pkt-change があります．

pkt-filter / pkt-change はそのままで使っても，意味はありません．

pkt-filter / pkt-change は，あくまで自前のフィルタ／交換プログラムを作るための
テンプレートとなっています．

パケットフィルタやパケット変換を行いたい場合は，まず filter.c / change.c の
ソースコードを直接書き換えて，期待のフィルタ／変換動作をするようにして
ください．ソースコードはさほど難しくは無く，テンプレート的に書いてあるので，
修正はそれほど難しくはないかと思います．

で，make して pkt-filter / pkt-change の実行ファイルを再生成することで，
期待の動作をするパケットフィルタ／パケット変換として利用することができます．

  % vi filter.c  (filter.cを直接修正することでフィルタ条件を任意に設定する)
  % vi change.c  (change.cを直接修正することで変換ルールを任意に設定する)
  % make    (再コンパイルすることで，希望の動作の pkt-filter/pkt-change を生成)
  % pkt-recv -i eth0 | pkt-filter | pkt-analyze      (フィルタ処理の例)
  % pkt-recv -i eth0 | pkt-change | pkt-correct | pkt-send -i eth1 (変換の例)

パケットフィルタやパケット変換を独自ルールや独自言語でやろうとすると
どうしても複雑になる割にはたいしたことは行えず記述方法をマスターする
だけでも面倒で，だったらそもそもＣ言語のソースコードを直接書き換えたほうが
いいんじゃね？ という判断でこのようにしています．

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ 各種ライブラリを利用してのビルドや，Windows版のビルドについて

■ libpcap の利用

標準ではパケットの送受信には，独自のライブラリ(FreeBSDではBPF，Linuxでは
RAWソケットを使っている)が利用されますが，libpcapを利用することもできます．
(ただし，とくに推奨するわけではないです．Windows対応のためにlibpcapに対応
させたのですが，ついでにFreeBSDやLinuxでも使えるようにしておいただけです)

libpcapを使いたい場合には，以下のようにします．

・Makefileの以下のフラグを有効にしてmakeしなおす．

  USE_LIBPCAP = yes

■ netlib の利用

Windows版のためのMinGW対応のために，netlibという簡単なライブラリ
(MinGWで利用できない／うまく使えなかったサービス関数などを補うもの)を作成して
あります．主にMinGW向けなので，FreeBSD/Linuxでの利用はとくに推奨はしませんが，
いちおう以下のようにすることで，netlibを使ってビルドすることができます．
netlibのライセンスに関しては，netlibのソースを参照してください．
(FreeBSD-8.3のライブラリを利用しており，BSDライセンスのコードを含んでいます)

(1) 必要なライブラリを準備する．

    ・netlib (http://kozos.jp/software/pkttools.html)

(2) 以下のように展開する．

    % unzip pkttools-X.X.zip
    % unzip netlib-X.X.zip
    % cd pkttools-X.X
    % ln -s ../netlib-X.X ./netlib

(3) 各種フラグを有効にする．

    % vi Makefile
      → 先頭で定義してある以下のフラグのコメントを外して有効にする

         USE_LIBPCAP = yes
         USE_NETLIB  = yes

      (netlibがBPF／RAWソケットに対応しておらずそれら関連の内容を持たないため，
       libpcapの利用が必要になります)

(4) makeしなおす．

    % make clean
    % make

■ Windows向けのビルド

pkttools-1.9 より Windows に対応しており，Windows版も配布しています．
Windows版はFreeBSD上でMinGWを利用して，以下のようにしてビルドできます．
(FreeBSD-9.3でビルドを確認しています)

(0) FreeBSD上に以下のportsをインストールする．

    devel/mingw32-binutils
    devel/mingw32-gcc
    devel/mingw32-bin-msvcrt

(1) 必要なライブラリを準備する．

    ・netlib (http://kozos.jp/software/pkttools.html)
    ・WinPcap (http://www.winpcap.org/)

(2) 以下のように展開する．

    % unzip pkttools-X.X.zip
    % unzip netlib-X.X.zip
    % unzip WpdPack_X_X_X.zip
    % cd pkttools-X.X
    % ln -s ../netlib-X.X ./netlib
    % ln -s ../WpdPack .

(3) 各種フラグを有効にする．

    % vi Makefile
      → 先頭で定義してある以下のフラグのコメントを外して有効にする

         USE_LIBPCAP = yes
         USE_WINPCAP = yes
         USE_NETLIB  = yes
         USE_MINGW   = yes

(4) makeしなおす．

    % make clean
    % make

ソケット利用の簡易ツールを Windows 向けに独立してビルドしたい場合には，
以下のようにしてください．
(通常は pkttools をビルドすると，ツール類も合わせてビルドされます)

(1) 各種フラグを有効にする．

    % cd tools
    % vi Makefile
      → 先頭で定義してある以下のフラグのコメントを外して有効にする

         USE_MINGW = yes

    (注意) こちらは netlib は不要ですので，USE_NETLIB は通常は無効にして
           おいてください．netlibは Windows 向けで USE_GETHOSTBYNAME を無効に
           したい際に，inet_pton() を利用するために必要になります．

(2) makeしなおす．

    % make clean
    % make

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
■ 利用の実践例

■ スクリプトと組み合わせて，パケットを自動生成＆送信してみる

例えば以下は，UDPのパケットのサンプルデータです．
適当なUDPパケットを送信して pkt-recv でキャプチャした内容を，
適当に修正したものです．

-- 1 --
TIME: 0.0 Thu Jan  1 09:00:00 1970
SIZE: 60/60
000000: 00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00 : .."3DU.. ......E.
000010: 00 2E 00 01  00 00 40 11  F7 6A C0 A8  01 02 C0 A8 : ......@. .j......
000020: 01 01 27 0F  27 10 00 1A  28 AC 54 68  69 73 20 69 : ..'.'... (.This i
000030: 73 20 55 44  50 20 74 65  73 74 2E 0A              : s UDP te st..    
==

このデータをベースにして，ポート番号を変更しながら複数のUDPパケットを
生成するようなスクリプト(udp.pl)を書いてみましょう．以下のような感じです．

#!/usr/bin/perl

for ($i = 0; $i < 256; $i++) {
    $n = sprintf("%02X", $i);
    print "--\n";
    print "00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00\n";
    print "00 2E 00 01  00 00 40 11  F7 6A C0 A8  01 02 C0 A8\n";
    print "01 01 7F FF  80 $n 00 1A  28 AC 54 68  69 73 20 69\n";
    print "73 20 55 44  50 20 74 65  73 74 2E 0A\n";
    print "==\n";
}

上の udp.pl は「$n」の部分でポート番号を順番に変更しながらパケット生成
しています．

もしくは，以下のようにフィールド値書き換えで実現してもいいでしょう．

#!/usr/bin/perl

for ($i = 0x8000; $i < 0x8000+256; $i++) {
    print "--\n";
    print "00 11 22 33  44 55 00 AA  BB CC DD EE  08 00 45 00\n";
    print "00 2E 00 01  00 00 40 11  F7 6A C0 A8  01 02 C0 A8\n";
    print "01 01 7F FF  00 00 00 1A  28 AC 54 68  69 73 20 69\n";
    print "73 20 55 44  50 20 74 65  73 74 2E 0A\n";
    print "UDP.DST_PORT: $i\n";
    print "==\n";
}

上の例では「UDP.DST_PORT」によりポート番号を上書き指定しています．

以下で，実際に生成したUDPパケットを確認できます．

% ./udp.pl | pkt-txt2txt

Wiresharkでも確認できます．

% ./udp.pl | pkt-txt2pcap > udp.pcap
% wireshark udp.pcap

以下のようにすることで，生成したUDPを送信することができます．
実際にはチェックサムが変わってきてしまうので，pkt-correct を通すことで
チェックサムを再計算＆再設定して送信できます．

% ./udp.pl | pkt-correct | pkt-send -i rl0

■ UDPのパケットを自作してみる

パケットをゼロから構築したい場合には，以下のようにするといいでしょう．
以下はUDPのパケットを作り上げる例です．

まず，SIZE: によりサイズを指定します．(おおまかでいい)
以下のような感じです．

--
SIZE: 100
==

適当なパラメータでEthernetヘッダを作成します．以下のような感じです．

--
SIZE: 100
ETHERNET.DST_ADDR: FF:FF:FF:FF:FF:FF
ETHERNET.SRC_ADDR: 00:11:22:33:44:55
ETHERNET.TYPE:     0x0800    (IPパケットを指定)
==

上の内容を udp.txt というファイルに保存し，見てみます．
タイプを0x0800(IP)にしたので，空のIPパケットとして解析されます．

% cat udp.txt
--
SIZE: 100
ETHERNET.DST_ADDR: FF:FF:FF:FF:FF:FF
ETHERNET.SRC_ADDR: 00:11:22:33:44:55
ETHERNET.TYPE:     0x0800    (IPパケットを指定)
==
% cat udp.txt | pkt-analyze
-- 1 --
received: 100 bytes    0.000000 Thu Jan  1 09:00:00 1970
00:11:22:33:44:55 -> ff:ff:ff:ff:ff:ff  (type: 0x0800)
IP      head/total size : 0 / 0 bytes
        ID/fragment     : 0x0000 / 0x0000
        TTL/protocol    : 0 / 0
        checksum        : 0x0000
        src/dst addr    : 0.0.0.0 / 0.0.0.0
==

udp.txt にIPヘッダの内容を適当に追加します．
フィールド名はツールを -k で実行することで一覧を出力させられます．

--
SIZE: 100
ETHERNET.DST_ADDR: FF:FF:FF:FF:FF:FF
ETHERNET.SRC_ADDR: 00:11:22:33:44:55
ETHERNET.TYPE:     0x0800
IP.VERSION:      4
IP.HEADER_SIZE: 20
IP.TOTAL_SIZE:  64
IP.TTL:         64
IP.PROTOCOL:    17
IP.SRC_ADDR:    192.168.1.1
IP.DST_ADDR:    192.168.1.2
==

解析して見てみます．
プロトコル番号を17(UDP)にしたので，UDPとして解析されています．

% cat udp.txt | pkt-analyze
-- 1 --
received: 100 bytes    0.000000 Thu Jan  1 09:00:00 1970
00:11:22:33:44:55 -> ff:ff:ff:ff:ff:ff  (type: 0x0800)
IP      head/total size : 20 / 64 bytes
        ID/fragment     : 0x0000 / 0x0000
        TTL/protocol    : 64 / 17
        checksum        : 0x0000
        src/dst addr    : 192.168.1.1 / 192.168.1.2
UDP     total size      : 44 bytes
        src/dst port    : 0 / 0
        length/checksum : 0 / 0x0000
==

udp.txt にUDPヘッダの内容を適当に追加します．
サイズも調整します．

--
SIZE: 78  (「Ethernetヘッダ＋IPヘッダ＋UDP」＝14＋20＋44＝78)
ETHERNET.DST_ADDR: FF:FF:FF:FF:FF:FF
ETHERNET.SRC_ADDR: 00:11:22:33:44:55
ETHERNET.TYPE:     0x0800
IP.VERSION:      4
IP.HEADER_SIZE: 20
IP.TOTAL_SIZE:  64
IP.TTL:         64
IP.PROTOCOL:    17
IP.SRC_ADDR:    192.168.1.1
IP.DST_ADDR:    192.168.1.2
UDP.SRC_PORT:   1000
UDP.DST_PORT:   1001
UDP.SIZE:       44
==

解析して見てみます．

% cat udp.txt | pkt-analyze
-- 1 --
received: 78 bytes    0.000000 Thu Jan  1 09:00:00 1970
00:11:22:33:44:55 -> ff:ff:ff:ff:ff:ff  (type: 0x0800)
IP      head/total size : 20 / 64 bytes
        ID/fragment     : 0x0000 / 0x0000
        TTL/protocol    : 64 / 17
        checksum        : 0x0000
        src/dst addr    : 192.168.1.1 / 192.168.1.2
UDP     total size      : 44 bytes
        src/dst port    : 1000 / 1001
        length/checksum : 44 / 0x0000
==

チェックサム計算をして，整形して保存します．

% cat udp.txt | pkt-correct -a > udp-data.txt

このようにして，パケットを自作することができます．

あとは udp-data.txt をいろいろに編集して使うことができます．
上の例では -a でフィールド値も含めて udp-data.txt を作成していますので，
フィールド値をいろいろに変更して使いたい場合に便利でしょう．

■ おしまい
